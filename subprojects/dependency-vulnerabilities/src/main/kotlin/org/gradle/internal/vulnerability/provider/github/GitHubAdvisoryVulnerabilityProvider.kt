/*
 * Copyright 2020 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.gradle.internal.vulnerability.provider.github

import com.expediagroup.graphql.client.GraphQLKtorClient
import io.ktor.client.engine.okhttp.OkHttp
import io.ktor.client.features.defaultRequest
import io.ktor.client.features.logging.DEFAULT
import io.ktor.client.features.logging.LogLevel
import io.ktor.client.features.logging.Logger
import io.ktor.client.features.logging.Logging
import io.ktor.client.request.header
import kotlinx.coroutines.runBlocking
import org.gradle.internal.vulnerability.DependencyHealthAnalyzer
import org.gradle.internal.vulnerability.provider.github.generated.SecurityVulnerabilitiesQuery
import java.net.URL
import java.util.concurrent.TimeUnit

class GitHubAdvisoryVulnerabilityProvider
private constructor(
    private val securityVulnerabilitiesQuery: SecurityVulnerabilitiesQuery
) : DependencyHealthAnalyzer {
    private val cache = mutableMapOf<String, DependencyHealthAnalyzer.HealthReport>()

    override fun analyze(group: String, name: String, version: String?): DependencyHealthAnalyzer.HealthReport {
        // TODO: This needs to include looking at versions, but we don't currently filter for versions
        return cache.computeIfAbsent("$group:$name") { analyzeImpl(group, name, version) }
    }

    private fun analyzeImpl(group: String, name: String, version: String?): DependencyHealthAnalyzer.HealthReport {
        val result = runBlocking {
            securityVulnerabilitiesQuery.execute(
                SecurityVulnerabilitiesQuery.Variables(
                    "$group:$name",
                    30
                )
            )
        }
        val errors = result.errors ?: emptyList()
        if (errors.isNotEmpty()) {
            throw RuntimeException(errors.joinToString())
        }

        val data = result.data ?: throw RuntimeException("Null Data")

        val nodes = (data.securityVulnerabilities.nodes ?: emptyList()).mapNotNull { it }

        val cves = nodes.mapNotNull { vuln ->
            val identifier = vuln.advisory.identifiers.firstOrNull { it.type == "CVE" }
            if (identifier == null) {
                null
            } else {
                object : DependencyHealthAnalyzer.Cve {
                    override fun getId(): String {
                        return identifier.value
                    }

                    override fun getSeverity(): DependencyHealthAnalyzer.Severity {
                        return when (vuln.advisory.severity) {
                            SecurityVulnerabilitiesQuery.SecurityAdvisorySeverity.CRITICAL -> DependencyHealthAnalyzer.Severity.CRITICAL
                            SecurityVulnerabilitiesQuery.SecurityAdvisorySeverity.HIGH -> DependencyHealthAnalyzer.Severity.HIGH
                            SecurityVulnerabilitiesQuery.SecurityAdvisorySeverity.MODERATE -> DependencyHealthAnalyzer.Severity.MEDIUM
                            SecurityVulnerabilitiesQuery.SecurityAdvisorySeverity.LOW -> DependencyHealthAnalyzer.Severity.LOW
                            SecurityVulnerabilitiesQuery.SecurityAdvisorySeverity.__UNKNOWN_VALUE -> throw RuntimeException("Unsupported severity `${vuln.advisory.severity}`")
                        }
                    }

                }
            }
        }

        return DependencyHealthAnalyzer.HealthReport { cves }
    }

    class Factory {

        @io.ktor.util.KtorExperimentalAPI
        fun createVulnerabilityProvider(): GitHubAdvisoryVulnerabilityProvider {
            val client = GraphQLKtorClient(
                url = URL("https://api.github.com/graphql"),
                engineFactory = OkHttp
            ) {
                engine {
                    config {
                        connectTimeout(10, TimeUnit.SECONDS)
                        readTimeout(60, TimeUnit.SECONDS)
                        writeTimeout(60, TimeUnit.SECONDS)
                    }
                }

                install(Logging) {
                    logger = Logger.DEFAULT
                    level = LogLevel.INFO
                }

                defaultRequest {
                    val token = System.getProperty(GITHUB_API_KEY_SYS_PROP)
                    header("Authorization", "bearer $token")
                }
            }
            return GitHubAdvisoryVulnerabilityProvider(SecurityVulnerabilitiesQuery(client))
        }

        companion object {
            private const val GITHUB_API_KEY_SYS_PROP = "org.gradle.dependency.github.key"
        }
    }

}
